#import AccessResource from 'accessresources.graphql'

type Query {
    individualAccess(username: String!): Access
    postAccess(postname: String!): Access
}

type Mutation {
    setIndividualAccess(username: String!, access:[Int!]!): Boolean!
    setPostAccess(postname: String!, access:[Int!]!): Boolean!
}

"Access will be treated as a immutable object!"
type Access {
    doors: [AccessResource!]!
    web: [AccessResource!]!
}
type Query {
	accessResources(type: AccessResourceType): [AccessResource!]!
	accessResource(id: Int!): AccessResource!
}

type Mutation {
	addAccessResource(name: String!, description: String!, resourceType: AccessResourceType!): AccessResource!
	removeAccessResource(id: Int!): Boolean!
}

type AccessResource {
	id: Int!
	name: String!
	description: String!
	resourceType: AccessResourceType!
}

enum AccessResourceType {
    DOOR,
    WEB
}#import User from 'user.graphql'

scalar Date
scalar DateTime

type Query {
  newsentries(creator: String, after: DateTime, before: DateTime, markdown: Boolean): [Article]!
  latestnews(limit: Int, markdown: Boolean): [Article]!
  article(id: ID, slug: String, markdown: Boolean): Article
  articles(id: ID, creator: String, lastUpdateBy: String, title: String, createdAt: DateTime, lastUpdatedAt: DateTime, signature: String, tags: [String], articleType: String, markdown: Boolean): [Article]!
}

type Mutation {
  addArticle(entry: NewArticle!): Article
  modifyArticle(articleId: Int!, entry: ModifyArticle!): Boolean!
}

"Body is saved as HTML serverside, but edited in MarkDown"
type Article {
  id: ID
  slug: String
  creator: User!
  lastUpdatedBy: User!
  title: String!
  body: String!
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  signature: String!
  tags: [String!]!
  articleType: ArticleType!
}

"News are the ones to be used by a website newsreel"
enum ArticleType {
  news
  information
}

input NewArticle {
  creator: String!
  title: String!
  body: String!
  signature: String!
  tags: [String!]
  articleType: ArticleType!
}

"We don't need every part; It should already exist"
input ModifyArticle {
  title: String
  body: String
  signature: String
  tags: [String!]
  articleType: ArticleType
}
# import User from 'user.graphql'

type Mutation {
  "Test user credentials and if valid get a jwt token"
  login(username: String!, password: String!): User
  logout: Boolean
  casLogin(token: String!): CasLoginResponse!
}

type CasLoginResponse {
  username: String!
  hash: String
  exists: Boolean!
}#import User from 'user.graphql'

scalar Date
scalar DateTime

type Query {
  files(type: FileType): [File!]!
  file(id: ID!): File!
  fileSystem(folder: String!): FileSystemResponse!
  searchFiles(search: String!): [File!]!
}


type Mutation {
  deleteFile(id: ID!): Boolean!
  createFolder(path: String!, name: String!): Boolean!
}

type File {
  id: ID!
  name: String!
  type: FileType!
  folderLocation: String!
  url: String
  accessType: AccessType!
  createdAt: DateTime!
  createdBy: User
  size: Int!
}

type FileSystemResponse {
  files: [File!]!
  path: [FileSystemResponsePath!]!
}

type FileSystemResponsePath {
  id: ID!
  name: String!
}

enum FileType {
  image,
  pdf,
  text,
  code,
  powerpoint,
  spreadsheet,
  folder,
  other,
}

enum AccessType {
  public,
  authenticated,
  admin
}# import File from 'file.graphql'

type Query {
  meeting(id: ID!): Meeting
  meetings(type: MeetingType, number: Int, year: Int): [Meeting]!
  latestBoardMeetings(limit: Int): [Meeting]!
}

type Mutation {
  addMeeting(type: MeetingType!, number: Int, year: Int): Boolean!
  removeMeeting(id: ID!): Boolean!
  addFileToMeeting(meetingId: ID!, fileId: ID!, fileType: MeetingDocumentType!): Boolean!
  removeFileFromMeeting(meetingId: ID!, fileType: MeetingDocumentType!): Boolean!
}

type Meeting {
  id: ID!
  name: String!
  type: MeetingType!

  """
  Styrelse- och extrainsatta möten har nummer efter hur många
  som varit det året (börjar på 1). VM/VTM/HTM får också
  för enkelhetens skull
  """
  number: Int!
  year: Int!

  "Kallelse"
  summons: File

  "Handlingar"
  documents: File
  lateDocuments: File
  protocol: File
}

enum MeetingType {
  
  "Styrelsemöte"
  SM

  "Höstterminsmöte"
  HTM

  "Valmöte"
  VM

  "Vårterminsmöte"
  VTM

  "Extrainsatt Sektionsmöte"
  Extra
}

enum MeetingDocumentType {
    "Kallelse"
  summons

  "Handlingar"
  documents
  lateDocuments
  protocol
}# import User from 'user.graphql'
# import Access from 'access.graphql'
# import Utskott from 'utskott.graphql'

scalar Date

type Query {
    post(name: String!): Post
    posts(utskott: Utskott, includeInactive: Boolean!): [Post]
}

type Mutation {
    addPost(info: NewPost!): Boolean!
    modifyPost(info: ModifyPost!): Boolean!
    addUsersToPost(usernames: [String!]!, postname: String!, period: Int!): Boolean!
    removeUsersFromPost(usernames: [String!]!, postname: String!): Boolean!
    activatePost(postname: String!): Boolean!
    deactivatePost(postname: String!): Boolean!
}

type Post {
    postname: String!
    utskott: Utskott!
    postType: PostType!

    """
    Hur många platser en post har.
    `-1` symboliserar godtyckligt antal
    """
    spots: Int!
    description: String!
    active: Boolean!
    access: Access!

    """
    Om sökande valbereds och kallas till intervju
    """
    interviewRequired: Boolean
    history: [HistoryEntry!]!
}

input NewPost {
    name: String!
    utskott: Utskott!
    postType: PostType!

    """
    Hur många platser en post har.
    `-1` symboliserar godtyckligt antal
    """
    spots: Int
    description: String

    """
    Om sökande valbereds och kallas till intervju
    """
    interviewRequired: Boolean
}

input ModifyPost {
    name: String!
    utskott: Utskott
    postType: PostType

    """
    Hur många platser en post har.
    `-1` symboliserar godtyckligt antal
    """
    spots: Int
    description: String

    """
    Om sökande valbereds och kallas till intervju
    """
    interviewRequired: Boolean
}

type HistoryEntry {
    postname: String!
    holder: User!
    start: Date!
    end: Date
}

type UserPostHistoryEntry {
  post: Post!
  start: Date!
  end: Date
}

"Hur en post tillsätts enligt Reglementet"
enum PostType {
    """
    Unik, finns bara 1, t.ex. utskottsordförande
    """
    U

    """
    Erfoderligt antal, dvs. så många som anses
    passande
    """
    EA

    """
    Upp till _n_ stycken
    """
    N

    """
    Exakt _n_ stycken
    """
    EXACT_N
}# Schemas

Här defineras alla graphql schemas. Dessa bestämmer vilka
anrop en konsument av api:n kan använda. För att skriva en bra
graphql api bör man vara lite insatt att det inte rikigt är som
metodanrop i java eller likt en REST api. [Exempel](https://medium.com/@graphcool/thinking-in-terms-of-graphs-7f5d960d05f9)# import Post, UserPostHistoryEntry from 'post.graphql'
# import Access from 'access.graphql'

scalar Date

type Query {
  user(username: String!): User
  searchUser(search: String!): [User!]!
  me: Me
}

type Mutation {
  createUser(input: NewUser!): Boolean!
  updateUser(input: UpdateUser!): Boolean!
  requestPasswordReset(username: String!): Boolean!
  validatePasswordResetToken(username: String!, token: String!): Boolean!
  resetPassword(username: String!, token: String!, password: String!): Boolean!
  casCreateUser(input: NewUser!, hash: String!): Boolean!
}

type User { 
  username: String!

  firstName: String!
  lastName: String!

  photoUrl: String
  email: String!
  phone: String

  address: String
  zipCode: String
  website: String

  class: String!

  """
  Currents posts held by this user
  """
  posts: [Post!]!

  """
  Past and current posts held by this user
  """
  userPostHistory: [UserPostHistoryEntry]!

  """
  This will be all the access have concated from Posts and personal
  """
  access: Access!

  isFuncUser: Boolean
}

input NewUser {
  username: String!
  firstName: String!
  lastName: String!
  class: String!
  email: String
  password: String!
  isFuncUser: Boolean
}

input UpdateUser {
  firstName: String
  lastName: String
  phone: String
  email: String
  address: String
  zipCode: String
  website: String
}

type Me {
  user: User
  accessExpiry: Float!
  refreshExpiry: Float!
}# Denna filen är för att vi ska ha ett gemensamt namn på
# utskotten

type Query {
    utskott(name: String): Utskott
}

enum Utskott {
    CM
    KM
    INFU
    E6
    NOJU
    NOLLU
    SRE
    ENU
    FVU
    STYRELSEN
    OTHER
}