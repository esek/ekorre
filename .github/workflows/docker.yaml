name: Docker Image CI

# To run this locally use act (https://github.com/nektos/act)

# To use act:
# Create a .secrets file and set all the needed variables
# Multiline variables need to be set using adding -s KEY="$(<value.txt)""
# And run the following command
# sudo act
# or
# sudo act -s KEY="$(<value.txt)"

on:
  push:
    branches: [main]
  pull_request:
  release:
    types: [released, prereleased]

env:
  REGISTRY: registry.esek.se
  PROD_URL: api.esek.se # Optional
  # STAGING_URL: blabla.esek.se # Optional
  DEFAULT_BRANCH: main
  ONLY_PROD: true

jobs:
  # This can only contain env vars and not secrets since actions is a fussy about it
  env-vars:
    runs-on: self-hosted
    container:
      image: ghcr.io/catthehacker/ubuntu:act-latest
    steps:
      - name: set variables
        id: vars
        run: |
          slugify () {
            iconv -t ascii//TRANSLIT \
            | tr -d "'" \
            | sed -E 's/[^a-zA-Z0-9]+/-/g' \
            | sed -E 's/^-+|-+$//g' \
            | tr "[:upper:]" "[:lower:]"
          }

          export BRANCH=
          if [ -z $GITHUB_HEAD_REF ]; then
            BRANCH=$(basename $GITHUB_REF)
          else
            BRANCH=$GITHUB_HEAD_REF
          fi
          echo "Running on $BRANCH"

          export TAG=${{ github.repository }}-ephermal

          if [ "$BRANCH" = "${{ env.DEFAULT_BRANCH }}" ]; then
            TAG=latest
          fi

          if ${{ github.ref_type == 'tag' }}; then
            BRANCH=${{ env.DEFAULT_BRANCH }}
            TAG=$BRANCH
          fi

          TAG=$(echo "$TAG" | slugify)
          export IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository }}:$TAG"

          echo "::echo::on"
          echo "::set-output name=image_name::$IMAGE_NAME"
          echo "::set-output name=tag::$TAG"
          echo "::set-output name=basename::$(basename ${{ github.repository }} | slugify)"
          echo "::echo::off"
      - name: select environment
        id: env
        run: |
          export ENV=testing
          export DEPLOY_ENV=testing
          export PROJ_BASE=${{ steps.vars.outputs.basename }}
          export TAG=${{ steps.vars.outputs.tag }}
          export PROJECT_NAME=$PROJ_BASE-testing

          if ${{ (github.event_name == 'release' && github.event.action == 'released') || env.ONLY_PROD == 'true' }}; then
            ENV=production
            DEPLOY_ENV=$ENV
            PROJECT_NAME=$PROJ_BASE-prod
          fi
          if ${{ github.event_name == 'release' && github.event.action == 'prereleased' }}; then
            ENV=staging
            DEPLOY_ENV=$ENV
            PROJECT_NAME=$PROJ_BASE-staging
          fi
          if ${{ github.event_name == 'pull_request' }}; then
            ENV=review
            DEPLOY_ENV=$TAG-review
            PROJECT_NAME=$PROJ_BASE-$TAG
          fi

          echo "::echo::on"
          echo "::set-output name=env::$ENV"
          echo "::set-output name=project_name::$PROJECT_NAME"
          echo "::set-output name=deploy_env::$DEPLOY_ENV"
          echo "::echo::off"
    outputs:
      image_name: ${{ steps.vars.outputs.image_name }}
      tag: ${{ steps.vars.outputs.tag }}
      basename: ${{ steps.vars.outputs.basename }}
      env: ${{ steps.env.outputs.env }}
      project_name: ${{ steps.env.outputs.project_name }}
      deploy_env: ${{ steps.env.outputs.deploy_env }}
  build:
    runs-on: self-hosted
    needs: env-vars
    if: ${{ !(github.event_name == 'pull_request' && github.event.action == 'closed') }}
    container:
      image: ghcr.io/catthehacker/ubuntu:act-latest
      volumes:
        - "/run/docker.sock:/run/docker.sock"
    steps:
      - name: import secrets
        id: s
        uses: hashicorp/vault-action@v2.4.1
        with:
          url: ${{ secrets.VAULT_URL }}
          token: ${{ secrets.VAULT_TOKEN }}
          method: token
          secrets: |
            kv/data/common registry_username;
            kv/data/common registry_password;
      - name: setup buildx
        uses: docker/setup-buildx-action@v2
        with:
          install: true
      - name: checkout repo
        uses: actions/checkout@v3
      - name: login to registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ steps.s.outputs.registry_username }}
          password: ${{ steps.s.outputs.registry_password }}
      - name: build and push image
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: ${{ needs.env-vars.outputs.image_name }}
  # This should need build and use the image to test
  test:
    runs-on: self-hosted
    # To run this locally using act set act to false in event.json
    # Note act does not support services...
    if: ${{ !github.event.act || !(github.event_name == 'pull_request' && github.event.action == 'closed') }}
    services:
      postgres:
        image: postgres:alpine
        env:
         POSTGRES_USER: postgres
         POSTGRES_PASSWORD: password
         POSTGRES_DB: ekorre_foot
    container:
      image: ghcr.io/catthehacker/ubuntu:act-latest
    steps:
      - name: checkout repo
        uses: actions/checkout@v3
      - name: setup env
        run: |
         mv .env.example.dev .env
         sed -i 's/localhost/postgres/' .env
         mkdir public.local
      - uses: actions/setup-node@v3
        with:
          node-version: 16  
      - name: install deps
        run: npm ci
      - name: lint
        run: npm run lint:ci
      - name: publish lint
        uses: ataylorme/eslint-annotate-action@v2
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
      - name: reset db
        run: npm run prisma:ci
      - name: run test
        run: npm run test:prebuild -- --ci --testLocationInResults --json --coverage --outputFile="report.json"
      - name: find pr
        uses: jwalton/gh-find-current-pr@v1
        id: findPr
      - name: publish coverage
        uses: ArtiomTr/jest-coverage-report-action@v2
        with:
          skip-step: all
          coverage-file: report.json
          base-coverage-file: report.json
          prnumber: ${{ steps.findPr.outputs.number }}

  deploy:
    # To run this locally using act set act to false in event.json
    if: ${{ !github.event.act || !(github.event_name == 'pull_request' && github.event.action == 'closed') }}
    runs-on: self-hosted
    needs: 
      - env-vars
      - build
    container:
      image: ghcr.io/catthehacker/ubuntu:act-latest
      volumes:
        - "/run/docker.sock:/run/docker.sock"
    steps:
      - name: import secrets
        id: s
        uses: hashicorp/vault-action@v2.4.1
        with:
          url: ${{ secrets.VAULT_URL }}
          token: ${{ secrets.VAULT_TOKEN }}
          method: token
          exportEnv: true
          secrets: |
            kv/data/common registry_username;
            kv/data/common registry_password;
            kv/data/common ssh_key;
            kv/data/common ssh_user;
            kv/data/common ssh_host;
            kv/data/${{ needs.env-vars.outputs.basename }}/${{ needs.env-vars.outputs.env }} DB_USER;
            kv/data/${{ needs.env-vars.outputs.basename }}/${{ needs.env-vars.outputs.env }} DB_PASSWORD;
            kv/data/${{ needs.env-vars.outputs.basename }}/${{ needs.env-vars.outputs.env }} DB_NAME;
            kv/data/${{ needs.env-vars.outputs.basename }}/${{ needs.env-vars.outputs.env }} DB_HOST;
            kv/data/${{ needs.env-vars.outputs.basename }}/${{ needs.env-vars.outputs.env }} DEPLOY_URL;
      - name: set variables
        run: |
          echo "IMAGE_NAME=${{ needs.env-vars.outputs.image_name }}" >> $GITHUB_ENV
          echo "TAG=${{ needs.env-vars.outputs.tag }}" >> $GITHUB_ENV
          echo "DEPLOY_ENV=${{ needs.env-vars.outputs.deploy_env }}" >> $GITHUB_ENV
          echo "PROJECT_NAME=${{ needs.env-vars.outputs.project_name }}" >> $GITHUB_ENV

          if [ ${{ needs.env-vars.outputs.env }} = 'review' ]; then
            echo "DEPLOY_URL=$TAG.review.esek.se" >> $GITHUB_ENV
          fi
      - name: checkout repo
        uses: actions/checkout@v3
      - name: start deployment
        uses: bobheadxi/deployments@v1
        id: deployment
        if: ${{ !env.ACT && github.event_name != 'pull_request' && needs.env-vars.outputs.env == 'review' }}
        with:
          step: start
          token: ${{ secrets.GITHUB_TOKEN }}
          override: true
          env: ${{ env.DEPLOY_ENV }}
      - name: login to host
        uses: nightstory/setup-docker-remote@v1
        with:
          ssh_key: ${{ steps.s.outputs.ssh_key }}
          ssh_host_user: ${{ steps.s.outputs.ssh_user }}
          ssh_host: ${{ steps.s.outputs.ssh_host }}
      - name: check connection
        run: |
          docker info
          docker compose version
      - name: login to registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ steps.s.outputs.registry_username }}
          password: ${{ steps.s.outputs.registry_password }}
      - name: pull image
        run: echo $IMAGE_NAME; docker pull $IMAGE_NAME
      - name: Stop old container
        run: |
          docker compose -f docker-compose.ci.yml -p $PROJECT_NAME down 2> /dev/null || true
      - name: deploy to host
        run: |
          docker compose -f docker-compose.ci.yml -p $PROJECT_NAME up -d --force-recreate ekorre
          if [ $ENV = 'review' ] || [ $ENV = 'testing' ]; then
            docker compose -f docker-compose.ci.yml -p $PROJECT_NAME up -d --force-recreate postgres
            docker compose -f docker-compose.ci.yml -p $PROJECT_NAME exec ekorre sh -c './wait-for-it.sh postgres:5432' 
            docker compose -f docker-compose.ci.yml -p $PROJECT_NAME exec ekorre sh -c 'npm run prisma:ci' 
          fi
      - name: prune system
        run: docker system prune -f 2> /dev/null || true
      - name: update deployment status
        uses: bobheadxi/deployments@v1
        if: ${{ always() && !env.ACT && github.event_name != 'pull_request' }}
        with:
          step: finish
          token: ${{ secrets.GITHUB_TOKEN }}
          status: ${{ job.status }}
          env: ${{ steps.deployment.outputs.env }}
          env_url: https://${{ env.DEPLOY_URL }}
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      - if: ${{ github.event.pull_request && github.event.action == 'opened' && !env.ACT }}
        name: comment deployment url to pr
        uses: mshick/add-pr-comment@v1
        with:
          message: I have deployed this PR to [${{ env.DEPLOY_URL }}](https://${{ env.DEPLOY_URL }}) 🚀
          repo-token: ${{ secrets.GITHUB_TOKEN }}

  teardown:
    runs-on: self-hosted
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'closed' }}
    needs: env-vars
    container:
      image: ghcr.io/catthehacker/ubuntu:act-latest
      volumes:
        - "/run/docker.sock:/run/docker.sock"
    steps:
      - name: import secrets
        id: s
        uses: hashicorp/vault-action@v2.4.1
        with:
          url: ${{ secrets.VAULT_URL }}
          token: ${{ secrets.VAULT_TOKEN }}
          method: token
          exportEnv: true
          secrets: |
            kv/data/common ssh_key;
            kv/data/common ssh_user;
            kv/data/common ssh_host;
      - name: login to host
        uses: nightstory/setup-docker-remote@v1
        with:
          ssh_key: ${{ steps.s.outputs.ssh_key }}
          ssh_host_user: ${{ steps.s.outputs.ssh_user }}
          ssh_host: ${{ steps.s.outputs.ssh_host }}
      - name: check connection
        run: |
          docker info
          docker compose version
      - name: stop container
        run: |
          docker compose -f docker-compose.ci.yml -p ${{ needs.env-vars.outputs.project_name }} down 2> /dev/null || true
      - name: prune system
        run: docker image prune -f 2> /dev/null || true
      - if: ${{ !env.ACT }}
        name: comment deployment url to pr
        uses: mshick/add-pr-comment@v1
        with:
          message: I have removed this deploy now 😇
          repo-token: ${{ secrets.GITHUB_TOKEN }}
