name: Docker Image CI

# To run this locally use act (https://github.com/nektos/act)

# To use act:
# Create a .secrets file and set all the needed variables
# Multiline variables need to be set using adding -s KEY="$(<value.txt)""
# And run the following command
# sudo act
# or
# sudo act -s KEY="$(<value.txt)"

on:
  push:
    branches: [main]
  pull_request:
  release:
    types: [released, prereleased]

env:
  REGISTRY: registry.esek.se
  PROD_URL: api.esek.se # Optional
  # STAGING_URL: blabla.esek.se # Optional
  DEFAULT_BRANCH: main
  # Setting env vars can be done by setting
  # PROD_ENV_VARS, STAGING_ENV_VARS, TESTING_ENV_VARS, PR_ENV_VARS
  ONLY_PROD: true
  SLUGIFY_FUNCTION: |
    slugify () {
      iconv -t ascii//TRANSLIT \
      | tr -d "'" \
      | sed -E 's/[^a-zA-Z0-9]+/-/g' \
      | sed -E 's/^-+|-+$//g' \
      | tr "[:upper:]" "[:lower:]"
    }

jobs:
  secrets:
    runs-on: self-hosted
    container:
      image: ghcr.io/catthehacker/ubuntu:act-latest
    steps:
      - name: Import Secrets
        id: s
        uses: hashicorp/vault-action@v2.4.1
        with:
          url: ${{ secrets.VAULT_URL }}
          method: token
          token: ${{ secrets.VAULT_TOKEN }}
          secrets: |
            kv/data/common registry_url;
            kv/data/common registry_username;
            kv/data/common registry_password;
    outputs:
      registry_url: ${{ steps.s.outputs.registry_url }}
      registry_username: ${{ steps.s.outputs.registry_username }}
      registry_password: ${{ steps.s.outputs.registry_password }}
  build:
    runs-on: self-hosted
    needs: secrets
    if: ${{ !(github.event_name == 'pull_request' && github.event.action == 'closed') }}
    container:
      image: ghcr.io/catthehacker/ubuntu:act-latest
      volumes:
        - "/run/docker.sock:/run/docker.sock"
    steps:
      - name: setup buildx
        uses: docker/setup-buildx-action@v2
        with:
          install: true
      - name: checkout repo
        uses: actions/checkout@v3
      - name: set variables
        id: vars
        run: |
          eval "$SLUGIFY_FUNCTION"

          if [ -z $GITHUB_HEAD_REF ]; then
            BRANCH=$(basename $GITHUB_REF)
          else
            BRANCH=$GITHUB_HEAD_REF
          fi
          echo "Running on $BRANCH"
          TAG=$BRANCH
          if [ "$BRANCH" = "${{ env.DEFAULT_BRANCH }}" ]; then
            TAG=latest
          fi

          if ${{ github.ref_type == 'tag' }}; then
            BRANCH=${{ env.DEFAULT_BRANCH }}
            TAG=latest
          fi

          TAG=$(echo "$TAG" | slugify)
          IMAGE_NAME="${{ needs.secrets.outputs.registry_url }}/${{ github.repository }}:$TAG"
          echo "::set-output name=image_name::$IMAGE_NAME"
          echo "::set-output name=tag::$TAG"
          echo $IMAGE_NAME
      - name: login to registry
        uses: docker/login-action@v2
        with:
          registry: ${{ needs.secrets.outputs.registry_url }}
          username: ${{ needs.secrets.outputs.registry_username }}
          password: ${{ needs.secrets.outputs.registry_password }}
      - name: build and push image
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          tags: ${{ steps.vars.outputs.image_name }}
    outputs:
      image_name: ${{ steps.vars.outputs.image_name }}
      tag: ${{ steps.vars.outputs.tag }}
  test:
    runs-on: self-hosted
    needs: 
      - build
      - secrets
    # To run this locally using act set act to false in event.json
    # Note act does not support services...
    if: ${{ !github.event.act || !(github.event_name == 'pull_request' && github.event.action == 'closed') }}
    services:
      postgres:
        image: postgres:alpine
        env:
         POSTGRES_USER: postgres
         POSTGRES_PASSWORD: password
         POSTGRES_DB: ekorre_foot
    container:
      image: ${{ needs.build.outputs.image_name }}
      credentials:
        username: ${{ needs.secrets.outputs.registry_username }}
        password: ${{ needs.secrets.outputs.registry_password }}
    steps:
      - name: install deps
        run: npm ci
      - name: setup env
        run: |
         mv .env.example.dev .env
         sed -i 's/localhost/postgres/' .env
         mkdir public.local
      - name: lint
        run: npm run lint:ci
      - name: publish lint
        uses: ataylorme/eslint-annotate-action@v2
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
      - name: reset db
        run: npm run prisma:ci
      - name: run test
        run: npm run test:prebuild -- --ci --testLocationInResults --json --coverage --outputFile="report.json"
      - name: find pr
        uses: jwalton/gh-find-current-pr@v1
        id: findPr
      - name: publish coverage
        uses: ArtiomTr/jest-coverage-report-action@v2
        with:
          skip-step: all
          coverage-file: report.json
          base-coverage-file: report.json
          prnumber: ${{ steps.findPr.outputs.number }}

  deploy:
    # To run this locally using act set act to false in event.json
    if: ${{ !github.event.act || !(github.event_name == 'pull_request' && github.event.action == 'closed') }}
    runs-on: self-hosted
    needs: build
    container:
      image: docker/compose
    steps:
      - name: checkout repo
        uses: actions/checkout@v3
      - name: set variables
        run: |
          eval "$SLUGIFY_FUNCTION"

          if [ -z $GITHUB_HEAD_REF ]; then
            BRANCH=$(basename $GITHUB_REF)
          else
            BRANCH=$GITHUB_HEAD_REF
          fi
          echo "Running on $BRANCH"
          TAG=$BRANCH
          if [ "$BRANCH" = "${{ env.DEFAULT_BRANCH }}" ]; then
            TAG=latest
          fi

          if ${{ github.ref_type == 'tag' }}; then
            BRANCH=${{ env.DEFAULT_BRANCH }}
            TAG=latest
          fi

          REPO_NAME=$(basename ${{ github.repository }})
          PROJECT_NAME=$REPO_NAME-${BRANCH/${{ env.DEFAULT_BRANCH }}/testing}

          TAG=$(echo "$TAG" | slugify)
          BRANCH_SLUG=$(echo "$BRANCH" | slugify)
          REPO_NAME_SLUG=$(echo "$REPO_NAME" | slugify)
          PROJECT_NAME=$(echo "$PROJECT_NAME" | slugify)

          DEPLOY_URL=$REPO_NAME_SLUG.testing.esek.se
          DEPLOY_ENV=${BRANCH_SLUG/${{ env.DEFAULT_BRANCH }}/testing}
          echo '${{ secrets.TESTING_ENV_VARS }}' > .env

          if ${{ (github.event_name == 'release' && github.event.action == 'released') || env.ONLY_PROD == 'true' }}; then
            DEPLOY_ENV=production
            PROJECT_NAME=production
            DEPLOY_URL=$REPO_NAME_SLUG.esek.se
            if [ -n '${{ env.PROD_URL }}' ]; then
              DEPLOY_URL=${{ env.PROD_URL }}
            fi
            echo '${{ secrets.PROD_ENV_VARS }}' > .env
          fi

          if ${{ github.event_name == 'release' && github.event.action == 'prereleased' }}; then
            DEPLOY_ENV=staging
            PROJECT_NAME=staging
            DEPLOY_URL=$REPO_NAME_SLUG.staging.esek.se
            if [ -n '${{ env.STAGING_URL }}' ]; then
              DEPLOY_URL=${{ env.STAGING_URL }}
            fi
            echo '${{ secrets.STAGING_ENV_VARS }}' > .env
          fi

          if ${{ github.event_name == 'pull_request' }}; then
            DEPLOY_ENV=review
            BASE=$REPO_NAME_SLUG-$BRANCH_SLUG
            PROJECT_NAME=$BRANCH_SLUG-review
            DEPLOY_URL=$BASE.review.esek.se
            echo '${{ secrets.PR_ENV_VARS }}' > .env
            echo NODE_ENV=development >> .env
          fi

          echo 'CI_REGISTRY_IMAGE=${{ env.REGISTRY }}/${{ github.repository }}' >> .env >> $GITHUB_ENV

          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "PROJECT_NAME=$PROJECT_NAME" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ env.REGISTRY }}/${{ github.repository }}:$TAG" >> $GITHUB_ENV
          echo "DEPLOY_URL=$DEPLOY_URL" >> $GITHUB_ENV
          echo "DEPLOY_ENV=$DEPLOY_ENV" >> $GITHUB_ENV
      - name: start deployment
        uses: bobheadxi/deployments@v1
        id: deployment
        if: ${{ !env.ACT && github.event_name != 'pull_request' }}
        with:
          step: start
          token: ${{ secrets.GITHUB_TOKEN }}
          override: true
          env: ${{ env.DEPLOY_ENV }}
      - name: login to host
        uses: nightstory/setup-docker-remote@v1
        with:
          ssh_key: ${{ secrets.SSH_KEY }}
          ssh_host_user: ${{ secrets.SSH_USER }}
          ssh_host: ${{ secrets.SSH_HOST }}
      - name: check connection
        run: |
          docker info
          docker compose version
      - name: login to registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      - name: pull image
        run: docker pull $IMAGE_NAME
      - name: Stop old container
        run: |
          docker compose -f docker-compose.ci.yml -p $PROJECT_NAME down 2> /dev/null || true
      - name: deploy to host
        run: |
          docker compose -f docker-compose.ci.yml -p $PROJECT_NAME --env-file .env up -d --force-recreate ekorre
          if [ $DEPLOY_ENV = 'review' ] || [ $DEPLOY_ENV = 'testing' ]; then
            docker compose -f docker-compose.ci.yml -p $PROJECT_NAME --env-file .env up -d --force-recreate postgres
            docker compose -f docker-compose.ci.yml -p $PROJECT_NAME exec ekorre sh -c './wait-for-it.sh postgres:5432' 
            docker compose -f docker-compose.ci.yml -p $PROJECT_NAME exec ekorre sh -c 'npm run prisma:ci' 
          fi
      - name: prune system
        run: docker system prune -f 2> /dev/null || true
      - name: update deployment status
        uses: bobheadxi/deployments@v1
        if: ${{ always() && !env.ACT && github.event_name != 'pull_request' }}
        with:
          step: finish
          token: ${{ secrets.GITHUB_TOKEN }}
          status: ${{ job.status }}
          env: ${{ steps.deployment.outputs.env }}
          env_url: https://${{ env.DEPLOY_URL }}
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      - if: ${{ github.event.pull_request && github.event.action == 'opened' && !env.ACT }}
        name: comment deployment url to pr
        uses: mshick/add-pr-comment@v1
        with:
          message: I have deployed this PR to [${{ env.DEPLOY_URL }}](https://${{ env.DEPLOY_URL }}) ðŸš€
          repo-token: ${{ secrets.GITHUB_TOKEN }}

  teardown:
    runs-on: self-hosted
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'closed' }}
    steps:
      - name: self hosted runner post job cleanup action
        uses: TooMuch4U/actions-clean@v2.1
      - name: setup variables
        run: |
          eval "$SLUGIFY_FUNCTION"

          if [ -z $GITHUB_HEAD_REF ]; then
            BRANCH=$(basename ${GITHUB_REF})
          else
            BRANCH=$GITHUB_HEAD_REF
          fi

          echo "Running on $BRANCH"
          REPO_NAME=$(basename ${{ github.repository }})

          PROJECT_NAME=$( echo "$REPO_NAME-$BRANCH-review" | slugify )
          echo "PROJECT_NAME=$PROJECT_NAME" >> $GITHUB_ENV
      - name: login to host
        uses: nightstory/setup-docker-remote@v1
        with:
          ssh_key: ${{ secrets.SSH_KEY }}
          ssh_host_user: ${{ secrets.SSH_USER }}
          ssh_host: ${{ secrets.SSH_HOST }}
      - name: check connection
        run: |
          docker info
          docker-compose version
      - name: stop container
        run: |
          docker-compose -f docker-compose.ci.yml -p $PROJECT_NAME down 2> /dev/null || true
      - name: prune system
        run: docker image prune -f 2> /dev/null || true
      - if: ${{ !env.ACT }}
        name: comment deployment url to pr
        uses: mshick/add-pr-comment@v1
        with:
          message: I have removed this deploy now ðŸ˜‡
          repo-token: ${{ secrets.GITHUB_TOKEN }}
