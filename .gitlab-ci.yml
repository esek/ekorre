# This is a GitLab CI configuration to build the project as a docker image
# The file is generic enough to be dropped in a project containing a working Dockerfile
# Author: Florent CHAUVEAU <florent.chauveau@gmail.com>
# Mentioned here: https://blog.callr.tech/building-docker-images-with-gitlab-ci-best-practices/

# do not use "latest" here, if you want this to work in the future
image: docker:19

stages:
  - test
  - build
  - push

variables:
  CONTAINER_TEST_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:latest

before_script:
  # docker login asks for the password to be passed through stdin for security
  # we use $CI_JOB_TOKEN here which is a special token provided by GitLab
  - echo -n $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY
  - docker info

build:
  stage: build
  only:
    - master
    - main
    - /^release-[0-9]\.[0-9]\.[0-9]$/
  script:
    - docker build -t $CONTAINER_TEST_IMAGE .
    - docker push $CONTAINER_TEST_IMAGE

lint:
  stage: test
  image: node:15
  # Make sure docker info is not run and get some node info
  before_script:
    - node --version
  script:
    - npm ci
    - npx eslint src
    - npx eslint test

tests:
  stage: test
  # Must be run on docker runner
  tags:
    - docker
  image:
    name: node:15-alpine
  before_script:
    - node --version
    - npm ci
    - apk update
    - apk add bash sqlite
    - ./test/utils/test-server-startup.sh
  script:
    - npm test
  artifacts:
    paths:
      - coverage
    expire_in: 1 week
  # Kill the node server
  after_script:
    # bash not default shell on alpine
    - bash -c kill -9 $( ps aux | grep '\snode\s' | awk '{print $2}' ) && echo "Killed dev server"

# # Here, the goal is to tag the "master" branch as "latest"
push latest:
  variables:
    # We are just playing with Docker here. 
    # We do not need GitLab to clone the source code.
    GIT_STRATEGY: none
  stage: push
  only:
    # Only "master" should be tagged "latest"
    - master
    - main
  script:
    # Because we have no guarantee that this job will be picked up by the same runner 
    # that built the image in the previous step, we pull it again locally
    - docker pull $CONTAINER_TEST_IMAGE
    # Then we tag it "latest"
    - docker tag $CONTAINER_TEST_IMAGE $CI_REGISTRY_IMAGE:latest
    # Annnd we push it.
    - docker push $CI_REGISTRY_IMAGE:latest

# Finally, the goal here is to Docker tag any Git tag
# GitLab will start a new pipeline everytime a Git tag is created, which is pretty awesome
push tag:
  variables:
    # Again, we do not need the source code here. Just playing with Docker.
    GIT_STRATEGY: none
  stage: push
  only:
    # We want this job to be run on tags only.
    - tags
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
